"""Base classes for simulation of dynamical processes"""
# !/usr/bin/python -tt
# -*- coding: utf-8 -*-
# =============================================================================
# File      : classes.py -- Base classes for processes
# Author    : Ingo Scholtes <scholtes@uni-wuppertal.de>
# Time-stamp: <Thu 2021-05-06 19:17 ingo>
#
# Copyright (c) 2016-2021 Pathpy Developers
# =============================================================================
import abc
from collections import defaultdict
from typing import Iterable, TYPE_CHECKING, Any, Optional, List, Dict, Tuple, Union, Set

from pandas import DataFrame

from pathpy.core.classes import BaseClass
from pathpy.core.api import Node
from pathpy.models.network import Network
from pathpy.models.directed_acyclic_graph import DirectedAcyclicGraph
from pathpy.models.temporal_network import TemporalNetwork, TemporalNode
from pathpy import tqdm, logger

# create logger
LOG = logger(__name__)

class BaseProcess:
    """Abstract base class for all implementations of discrete-time dynamical processes.
    """

    def __init__(self, network:Network):
        """initialize process."""
        self._network = network
        self.init(self.random_seed())

    @property
    def network(self) -> Network:
        return self._network 

    @abc.abstractmethod
    def init(self, seed: Any) -> None:
        """Abstract method to initialize the process with a given seed state."""

    @abc.abstractmethod
    def random_seed(self) -> Any:
        """Abstract method to generate a random seed state for the process."""

    @abc.abstractmethod
    def step(self) -> Iterable[str]:
        """Abstract method to simulate a single step of the process. Returns 
        an iterable of node uids whose state has been changed in this step."""

    @abc.abstractproperty
    def time(self) -> int:
        """Abstract property returning the current time."""

    @abc.abstractmethod
    def state_to_color(self, Any) -> Union[Tuple[int, int, int], str]:
        """Abstract method mapping node states to RGB colors or color names."""

    @abc.abstractmethod
    def node_state(self, v: str) -> Any:
        """Abstract method returning the current state of a given node."""

    def simulation_run(self, steps: int, seed: Optional[Any]=None) -> Tuple[int, Set[str]]:
        """Abstract generator method that initializes the process, runs a number of steps and yields a tuple consisting of the current time and the set of nodes whose state has changed in each step."""
        if seed == None:
            self.init(self.random_seed())
        else:
            self.init(seed)
        for _ in range(steps):
            ret = self.step()
            if ret is not None:
                yield self.time, ret
            else:
                return None

    def run_experiment(self, steps: int, runs: Optional[Union[int, Iterable[Any]]] = 1) -> DataFrame:
        """Perform one or more simulation runs of the process with a given number of steps."""

        # Generate initializations for different runs
        seeds: List=list()
        if type(runs) == int:
            for s in range(runs):
                seeds.append(self.random_seed())
        else:
            for s in runs:
                seeds.append(s)

        results = list()
        run_id: int = 0
        for seed in tqdm(seeds):
            
            # initialize seed state and record initial state
            self.init(seed)
            for v in self.network.nodes.uids:
                results.append({'run_id': run_id, 'seed': seed, 'time': self.time, 'node': v, 'state': self.node_state(v)})

            # simulate the given number of steps
            for time, updated_nodes in self.simulation_run(steps, seed):
                # print(updated_nodes)
                # record the new state of each changed node
                for v in updated_nodes:
                    results.append({'run_id': run_id, 'seed': seed, 'time': time, 'node': v, 'state': self.node_state(v)})
            run_id += 1

        return DataFrame.from_dict(results)


    def plot(self, data: DataFrame, run_id: int=0, timescale: Optional[int]=100, **kwargs):
        """
        Display an interactive plot of the evolution of a process based on a recorded simulation experiment

        Parameters
        ----------
        data: DataFrame
            A pandas dataframe containing the state changes recorded in a simulation of the process, as generated by function `run_experiment`
        
        run_id: Optional[int]=0
            The integer identifier of the simulation run contained in `data` that shall be visualized. 
            If omitted, a default value of zero is used, i.e. the first simulation run in `data` will 
            be visualized. 

        timescale: Optional[int]=100
            Determines the speed of the visualisation. For the default value of 100, each simulation step
            will be displayed for 100 timesteps in the visualisation.

        **kwargs
            Optional keyword-arguments that will be passed to the plot function of the underlying instance 
            of TemporalNetwork

        Examples
        --------

        Generate 10 random walks and visualize the walk dynamics of the run with id 3

        >>> n = pp.Network(directed=False)
        >>> n.add_edge('a', 'b')
        >>> rw = pp.processes.RandomWalk(n)
        >>> data = rw.run_experiment(steps=100, runs=10)
        >>> rw.plot(data, run_id=3)

        See Also:
        ---------
        TemporalNetwork, plot, RandomWalk, HigherOrderRandomWalk, EpidemicSIR
        """

        evolution: DataFrame = data.loc[data['run_id']==run_id]

        start_time = evolution.min()['time']
        end_time = evolution.max()['time']

        if end_time <= start_time:
            LOG.warning('Run data does not contain time evolution')
            return None

        # print(start_time)    
        # print(end_time)
        
        # create network with temporal attributes
        tn = TemporalNetwork(directed=self.network.directed)        
        for v in self.network.nodes:
            tn.add_node(TemporalNode(v.uid))
        
        if isinstance(self.network, TemporalNetwork):
            for start, end, e in self.network.tedges:
                edge = self.network.edges[e]
                if start >= start_time and start < end_time:
                    tn.add_edge(edge.v.uid, edge.w.uid, start=max(start, start_time), end=min(end_time, end))
            # # set initial state
            # for v in tn.nodes.uids:
            #     tn.nodes[v][start_time, 'color'] = self.state_to_color(self.node_state(v))
            # update state
            for index, row in evolution.iterrows():
                tn.nodes[row['node']][row['time'], 'color'] = self.state_to_color(row['state'])
        else:

            for e in self.network.edges:
                tn.add_edge(e.v.uid, e.w.uid, start=start_time, end=end_time*timescale)
            # # set initial state
            # for v in tn.nodes.uids:
            # for index, row in evolution.loc['time'==start_time].iterrows():
            #     tn.nodes[v][0, 'color'] = self.state_to_color(evolution.loc['time'==start_time]['state'])
            # update state
            for index, row in evolution.iterrows():
                tn.nodes[row['node']][row['time']*timescale, 'color'] = self.state_to_color(row['state'])
        
        
        return tn.plot(**kwargs)


    def to_directed_acylic_graph(self, data: DataFrame, run_id: Optional[int]=0, time_delta: Optional[int]=None, states: Optional[Iterable[Any]]=None) -> DirectedAcyclicGraph:
        """Returns a directed acyclic graph representation of all state changes over time.
        In this graph an edge (v_t' -> w_t) indicates that node w changed to state x at time t after a 
        connected node v previously changed its state to x at time t' < t (i.e. (v,w) exists in the network).

        A link (v-t') -> (w-t) in the directed acyclic graph indicates that node v may have causally influenced node w at time t. As an example, for a an SIR epidemic spreading process, the DAG representation captures possible transmission routes.

        Parameters
        ----------
        data: DataFrame
            recorded state changes of nodes, as returned by `run_experiment`

        run_id: Optional[int]=0
            identifier of simulation run to turn into DAG

        time_delta: Optional[int]=None
            maximum time difference of possible influence, i.e. if set to delta, any state changes between connected nodes that are apart further than delta time steps are not considered. If None (default) the last prior state change of any connected node is considered, independent of the 
            time distance

        states: Optional[Iterable[Any]]=None
            Only changes to states in this set will be considered. If None (default) all state changes will be considered
        """
        dag = DirectedAcyclicGraph(uid='{0}'.format(run_id))
        run = data.loc[data['run_id']==run_id]

        for index, row in run.iterrows():            
            # add temporal node            
            state = row['state']            
            if states and state not in states:
                continue

            w = row['node']
            t = row['time']
            uid = '{0}-{1}'.format(w, t)
            dag.add_node(uid, node_label=w, time=t, state=state)

            # find predecessor of node v that last changed its state
            predecessors = []
            for v in self._network.predecessors[w]:

                # get all state changes of node v prior to time t
                candidates = run.loc[(run['node']==v.uid) & (run['time']<t)]

                if len(candidates)>0:

                    # find time stamp and new state of last state change
                    r = candidates['time'].argmax()
                    last_time = candidates.iloc[r]['time']
                    last_state = candidates.iloc[r]['state']

                    # check last state change and time difference
                    if  last_state in states and (time_delta is None or (t-last_time) < time_delta):
                        pred_uid = '{0}-{1}'.format(v.uid, last_time)
                        if pred_uid not in dag.nodes:
                            predecessors.append(Node(pred_uid, node_label=v.uid, time=last_time, state=last_state))
                        else:
                            predecessors.append(dag.nodes[pred_uid])
                        # predecessors = ['{0}-{1}'.format(v.uid, t_p)]                        
                    #elif :                        

            for v in predecessors:
                dag.add_edge(v, dag.nodes[uid])
            
        return dag


